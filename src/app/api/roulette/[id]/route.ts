import { prisma } from "@/lib/prisma";
import { isTwoPhaseRedemptionEnabled } from "@/lib/featureFlags";
import { NextRequest } from "next/server";
import { pickWeighted } from "@/lib/pickWeighted";
import { logEvent } from "@/lib/log";
import { checkRateLimit } from "@/lib/rateLimit";
import { apiError, apiOk } from '@/lib/apiError';

interface SnapshotPrize { prizeId: string; label: string; color: string | null; count: number }
interface SnapshotToken { tokenId: string; prizeId: string; label: string; color: string | null }
interface SnapshotMetaPrize { mode: 'BY_PRIZE'; prizes: SnapshotPrize[]; createdAt: string }
interface SnapshotMetaToken { mode: 'BY_TOKEN'; tokens: SnapshotToken[]; createdAt: string }
type SnapshotMeta = SnapshotMetaPrize | SnapshotMetaToken | (Record<string, any> & { mode: string });

// Calcula la distribución real vs esperada dado el snapshot inicial y los spins (incluyendo el elegido en esta transacción)
function computeDistribution(snapshot: SnapshotMeta, spinsHistory: any[], chosenPrizeId: string) {
  // Construir conteos iniciales por premio
  const initialCounts = new Map<string, { prizeId: string; label: string; color: string | null; initial: number }>();
  if ((snapshot as any).mode === 'BY_PRIZE' && (snapshot as any).prizes) {
    for (const p of (snapshot as any).prizes as SnapshotPrize[]) {
      initialCounts.set(p.prizeId, { prizeId: p.prizeId, label: p.label, color: p.color, initial: p.count });
    }
  } else if ((snapshot as any).mode === 'BY_TOKEN' && (snapshot as any).tokens) {
    for (const t of (snapshot as any).tokens as SnapshotToken[]) {
      if (!initialCounts.has(t.prizeId)) initialCounts.set(t.prizeId, { prizeId: t.prizeId, label: t.label, color: t.color, initial: 0 });
      initialCounts.get(t.prizeId)!.initial++;
    }
  }
  const totalInitial = Array.from(initialCounts.values()).reduce((a, v) => a + v.initial, 0) || 1;
  // Conteos reales (spins previos + actual)
  const actualCounts = new Map<string, number>();
  for (const s of spinsHistory) {
    actualCounts.set(s.prizeId, (actualCounts.get(s.prizeId) || 0) + 1);
  }
  actualCounts.set(chosenPrizeId, (actualCounts.get(chosenPrizeId) || 0) + 1);
  const totalSpins = spinsHistory.length + 1;
  const perPrize: Array<any> = [];
  let chiSquare = 0;
  let maxAbsDeviationPct = 0;
  for (const { prizeId, label, color, initial } of initialCounts.values()) {
    const expectedPct = initial / totalInitial;
    const expected = expectedPct * totalSpins;
    const actual = actualCounts.get(prizeId) || 0;
    const actualPct = actual / totalSpins;
    const deviation = actual - expected;
    const deviationPct = actualPct - expectedPct;
    if (expected > 0) chiSquare += (deviation * deviation) / expected;
    const absDevPct = Math.abs(deviationPct);
    if (absDevPct > maxAbsDeviationPct) maxAbsDeviationPct = absDevPct;
    perPrize.push({ prizeId, label, color, initial, expected: Number(expected.toFixed(4)), expectedPct: Number(expectedPct.toFixed(6)), actual, actualPct: Number(actualPct.toFixed(6)), deviation: Number(deviation.toFixed(4)), deviationPct: Number(deviationPct.toFixed(6)) });
  }
  return {
    totalSpins,
    totalInitial,
    chiSquare: Number(chiSquare.toFixed(6)),
    maxAbsDeviationPct: Number(maxAbsDeviationPct.toFixed(6)),
    prizes: perPrize.sort((a, b) => a.prizeId.localeCompare(b.prizeId)),
  };
}

export async function GET(_req: NextRequest, { params }: { params: { id: string } }) {
  const { id } = params;
  if (!id) return apiError('ID_REQUIRED', 'ID requerido', undefined, 400);

  // Access rouletteSession model (generated by Prisma). Cast prisma as any to avoid stale type tooling issues.
  const session = await (prisma as any).rouletteSession.findUnique({
    where: { id },
  include: { spinsHistory: { orderBy: { order: "asc" } } },
  });
  if (!session) return apiError('NOT_FOUND', 'Sesión no encontrada', undefined, 404);

  let snapshot: SnapshotMeta;
  try {
    snapshot = JSON.parse(session.meta) as SnapshotMeta;
  } catch {
    return apiError('BAD_SNAPSHOT', 'Snapshot inválido', undefined, 500);
  }

  // Recalcular remaining a partir del snapshot y spins
  const remainingMap = new Map<string, { prizeId: string; label: string; color: string | null; remaining: number }>();
  let remaining: any[] = [];
  let finished = false;
  if ((snapshot as any).mode === 'BY_PRIZE' && (snapshot as any).prizes) {
    for (const p of (snapshot as any).prizes as SnapshotPrize[]) {
      remainingMap.set(p.prizeId, { prizeId: p.prizeId, label: p.label, color: p.color, remaining: p.count });
    }
    for (const spin of session.spinsHistory) {
      const item = remainingMap.get(spin.prizeId);
      if (item && item.remaining > 0) item.remaining -= 1; // proteger bajo cero
    }
    remaining = Array.from(remainingMap.values()).filter((r) => r.remaining > 0);
    finished = session.status !== "ACTIVE" || remaining.length === 0;
  } else if ((snapshot as any).mode === 'BY_TOKEN' && (snapshot as any).tokens) {
    const tokensAll = (snapshot as any).tokens as SnapshotToken[];
    const consumedOrders = new Set((session.spinsHistory as any[]).map(s => s.order));
    // Tokens restantes = total maxSpins - spinsHistory length
    const consumedCount = (session.spinsHistory as any[]).length;
    const remainingCount = session.maxSpins - consumedCount;
    finished = session.status !== 'ACTIVE' || remainingCount === 0;
    // Para GET devolvemos conteo agrupado por prizeId de tokens no consumidos
    const prizeRemaining = new Map<string, { prizeId: string; label: string; color: string | null; remaining: number }>();
    // En BY_TOKEN el orden de consumo se deriva de spinsHistory.order, pero snapshot no almacena mapping token->order; consumimos secuencialmente según aparición
    // Simple: reconstruir tokens consumidos = first N tokensAll (N = spinsHistory.length)
    const tokensRemaining = tokensAll.slice(consumedCount);
    for (const t of tokensRemaining) {
      if (!prizeRemaining.has(t.prizeId)) prizeRemaining.set(t.prizeId, { prizeId: t.prizeId, label: t.label, color: t.color, remaining: 0 });
      prizeRemaining.get(t.prizeId)!.remaining++;
    }
    remaining = Array.from(prizeRemaining.values());
  } else {
    finished = session.status !== 'ACTIVE';
  }

  // Enriquecer spins con estado de token si existe tokenId
  const tokenIds = session.spinsHistory.map((s: any) => s.tokenId).filter((t: any) => !!t);
  let tokenMap: Record<string, { id: string; revealedAt: Date | null; deliveredAt: Date | null; redeemedAt: Date | null }> = {};
  if (tokenIds.length) {
    try {
      const tokens = await (prisma as any).token.findMany({
        where: { id: { in: tokenIds } },
        select: { id: true, revealedAt: true, deliveredAt: true, redeemedAt: true }
      });
      tokenMap = Object.fromEntries(tokens.map((t: any) => [t.id, t]));
    } catch (e: any) {
      // If the underlying DB/schema lacks two-phase columns (revealedAt), fallback to raw select
      if (e && e.code === 'P2022') {
        try {
          const safeList = tokenIds.map((id: string) => `'${id.replace("'", "''")}'`).join(',');
          const rows: any[] = await prisma.$queryRawUnsafe(`SELECT id, deliveredAt, redeemedAt FROM Token WHERE id IN (${safeList})`);
          tokenMap = Object.fromEntries(rows.map((r: any) => [r.id, { id: r.id, revealedAt: null, deliveredAt: r.deliveredAt ?? null, redeemedAt: r.redeemedAt ?? null }]));
        } catch {
          // last-resort: leave tokenMap empty
          tokenMap = {};
        }
      } else {
        throw e;
      }
    }
  }

  return apiOk({
      sessionId: session.id,
      batchId: session.batchId,
      mode: session.mode,
      status: session.status,
      twoPhase: isTwoPhaseRedemptionEnabled(),
      spins: session.spinsHistory.map((s: any) => ({
        id: s.id as string,
        prizeId: s.prizeId as string,
        order: s.order as number,
        weightSnapshot: s.weightSnapshot as number,
        createdAt: s.createdAt as Date,
        tokenId: s.tokenId || null,
        token: s.tokenId && tokenMap[s.tokenId] ? {
          revealedAt: tokenMap[s.tokenId].revealedAt,
          deliveredAt: tokenMap[s.tokenId].deliveredAt,
          redeemedAt: tokenMap[s.tokenId].redeemedAt,
        } : null,
      })),
      snapshot,
      remaining,
      finished,
      maxSpins: session.maxSpins,
      createdAt: session.createdAt,
      finishedAt: session.finishedAt,
    });
}

export async function POST(_req: NextRequest, { params }: { params: { id: string } }) {
  const { id } = params;
  if (!id) return apiError('ID_REQUIRED', 'ID requerido', undefined, 400);

  // Rate limit por IP similar a batch generation
  const ipHeader = _req.headers.get("x-forwarded-for") || _req.headers.get("x-real-ip") || "unknown";
  const ip = ipHeader.split(",")[0].trim();
  const rl = checkRateLimit(`rouletteSpin:${ip}`);
  if (!rl.ok) {
    await logEvent("ROULETTE_SPIN", "Spin bloqueado por rate limit", {
      sessionId: id,
      reason: "RATE_LIMIT",
      retryAfterSeconds: rl.retryAfterSeconds,
      ip,
    });
    return apiError('RATE_LIMIT', 'Rate limit', { retryAfterSeconds: rl.retryAfterSeconds }, 429, { 'Retry-After': rl.retryAfterSeconds.toString() });
  }

  // Ejecutar dentro de una transacción para asegurar consistencia de orden y estado
  const twoPhase = isTwoPhaseRedemptionEnabled();

  try {
  const result = await prisma.$transaction(async (tx: any) => {
      const session = await tx.rouletteSession.findUnique({
        where: { id },
        include: { spinsHistory: { orderBy: { order: "asc" } } },
      });
      if (!session) return { status: 404, body: { code: 'NOT_FOUND', message: 'Sesión no encontrada' } } as const;
      if (session.status === "CANCELLED") {
        return { status: 409, body: { code: 'CANCELLED', message: 'Sesión cancelada' } } as const;
      }
      if (session.status === "FINISHED") {
        return { status: 409, body: { code: 'FINISHED', message: 'Sesión finalizada' } } as const;
      }
  let snapshot: SnapshotMeta;
      try {
        snapshot = JSON.parse(session.meta) as SnapshotMeta;
      } catch {
        return { status: 500, body: { code: 'BAD_SNAPSHOT', message: 'Snapshot inválido' } } as const;
      }
      const nextOrder = session.spinsHistory.length + 1;
  if ((snapshot as any).mode === 'BY_PRIZE' && (snapshot as any).prizes) {
        const remainingMap = new Map<string, { prizeId: string; label: string; color: string | null; remaining: number }>();
        for (const p of (snapshot as any).prizes as SnapshotPrize[]) {
          remainingMap.set(p.prizeId, { prizeId: p.prizeId, label: p.label, color: p.color, remaining: p.count });
        }
        for (const spin of session.spinsHistory) {
          const item = remainingMap.get(spin.prizeId);
          if (item && item.remaining > 0) item.remaining -= 1;
        }
        const remainingArr = Array.from(remainingMap.values()).filter((r) => r.remaining > 0);
        if (!remainingArr.length) {
          await tx.rouletteSession.update({
            where: { id: session.id },
            data: { status: session.status === 'ACTIVE' ? 'FINISHED' : session.status, finishedAt: session.finishedAt ?? new Date() },
          });
            return { status: 409, body: { code: 'FINISHED', message: 'Sesión finalizada' } } as const;
        }
        const weighted = remainingArr.map((r) => ({ id: r.prizeId, weight: r.remaining }));
        const chosenPrizeId = pickWeighted(weighted);
        const chosenMeta = remainingArr.find((r) => r.prizeId === chosenPrizeId)!;
        const weightSnapshot = chosenMeta.remaining;
  // Asignar token real: en two-phase sólo marca reveal (revealedAt + assignedPrizeId); en legacy marca redeemedAt directo
        let consumedTokenId: string | null = null;
        let revealedAt: Date | null = null;
        try {
          // Seleccionar token disponible del premio
          const token = await tx.token.findFirst({ where: { batchId: session.batchId, prizeId: chosenPrizeId, disabled: false, OR: twoPhase ? [{ revealedAt: null }] : [{ redeemedAt: null }] }, select: { id: true } });
          if (token) {
            if (twoPhase) {
              revealedAt = new Date();
              const upd = await tx.token.update({
                where: { id: token.id },
                data: { revealedAt, assignedPrizeId: chosenPrizeId },
                select: { id: true }
              });
              consumedTokenId = upd.id;
            } else {
              const upd = await tx.token.update({ where: { id: token.id }, data: { redeemedAt: new Date() }, select: { id: true } });
              consumedTokenId = upd.id;
            }
          }
        } catch { /* noop */ }
  await tx.rouletteSpin.create({ data: { sessionId: session.id, prizeId: chosenPrizeId, order: nextOrder, weightSnapshot, tokenId: consumedTokenId } });
        chosenMeta.remaining -= 1;
        const remainingAfter = remainingArr.reduce((a, r) => a + r.remaining, 0);
        const finishedNow = remainingArr.every((r) => r.remaining === 0);
        await tx.rouletteSession.update({ where: { id: session.id }, data: { spins: { increment: 1 }, status: finishedNow ? 'FINISHED' : 'ACTIVE', finishedAt: finishedNow ? new Date() : session.finishedAt } });
        const remainingResponse = remainingArr
          .map((r) => ({ prizeId: r.prizeId, count: r.remaining, label: r.label, color: r.color }))
          .filter((r) => r.count > 0);
        const deferredLogs: Array<{ type: string; message: string; metadata: any }> = [
          { type: 'ROULETTE_SPIN', message: 'Spin ruleta', metadata: { sessionId: session.id, prizeId: chosenPrizeId, order: nextOrder, remainingTotal: remainingAfter, finished: finishedNow, phase: twoPhase ? 'REVEALED' : 'LEGACY_REDEEM', tokenId: consumedTokenId } },
        ];
        if (twoPhase && consumedTokenId && revealedAt) {
          deferredLogs.push({
            type: 'TOKEN_REVEALED',
            message: 'Token prize revealed',
            metadata: {
              sessionId: session.id,
              tokenId: consumedTokenId,
              prizeId: chosenPrizeId,
              assignedPrizeId: chosenPrizeId,
              order: nextOrder,
              revealedAt
            }
          });
        }
        if (finishedNow) {
          // Calcular distribución real vs esperada al finalizar
          const distribution = computeDistribution(snapshot, session.spinsHistory, chosenPrizeId);
          deferredLogs.push({ type: 'ROULETTE_FINISH', message: 'Ruleta finalizada', metadata: { sessionId: session.id, totalSpins: nextOrder, distribution } });
        }
        if (twoPhase) {
          return {
            status: 200,
            body: {
              phase: 'REVEALED',
              tokenId: consumedTokenId,
              prize: { prizeId: chosenPrizeId, label: chosenMeta.label, color: chosenMeta.color },
              // Backwards-compatible legacy field expected by some callers/tests
              chosen: { prizeId: chosenPrizeId, label: chosenMeta.label, color: chosenMeta.color, tokenId: consumedTokenId },
              order: nextOrder,
              finished: finishedNow,
              remaining: remainingResponse,
              timestamps: { revealedAt },
              _logs: deferredLogs,
            }
          } as const;
        }
        return { status: 200, body: { chosen: { prizeId: chosenPrizeId, label: chosenMeta.label, color: chosenMeta.color, tokenId: consumedTokenId }, order: nextOrder, finished: finishedNow, remaining: remainingResponse, _logs: deferredLogs } } as const;
      } else if ((snapshot as any).mode === 'BY_TOKEN' && (snapshot as any).tokens) {
        const tokensAll = (snapshot as any).tokens as SnapshotToken[];
        const consumed = session.spinsHistory.length; // tokens consumidos = spins previos
        if (consumed >= tokensAll.length) {
          await tx.rouletteSession.update({ where: { id: session.id }, data: { status: 'FINISHED', finishedAt: session.finishedAt ?? new Date() } });
          return { status: 409, body: { code: 'FINISHED', message: 'Sesión finalizada' } } as const;
        }
        const remainingTokens = tokensAll.slice(consumed); // tokens aún disponibles
        const chosenIndex = Math.floor(Math.random() * remainingTokens.length);
        const chosenToken = remainingTokens[chosenIndex];
        // weightSnapshot = número de tokens restantes del mismo premio antes de extraer
        const prizeRemainingBefore = remainingTokens.filter(t => t.prizeId === chosenToken.prizeId).length;
        let revealedAt: Date | null = null;
        if (twoPhase) {
          try {
            revealedAt = new Date();
            await tx.token.update({ where: { id: chosenToken.tokenId, revealedAt: null }, data: { revealedAt, assignedPrizeId: chosenToken.prizeId } });
          } catch { /* carrera inofensiva */ }
        } else {
          try {
            await tx.token.update({ where: { id: chosenToken.tokenId, redeemedAt: null }, data: { redeemedAt: new Date() } });
          } catch { /* carrera inofensiva */ }
        }
  await tx.rouletteSpin.create({ data: { sessionId: session.id, prizeId: chosenToken.prizeId, order: nextOrder, weightSnapshot: prizeRemainingBefore, tokenId: chosenToken.tokenId } });
        const finishedNow = consumed + 1 === tokensAll.length;
        await tx.rouletteSession.update({ where: { id: session.id }, data: { spins: { increment: 1 }, status: finishedNow ? 'FINISHED' : 'ACTIVE', finishedAt: finishedNow ? new Date() : session.finishedAt } });
        // Recalcular remaining agrupado tras extracción: tokensAll.slice(consumed+1)
        const afterTokens = tokensAll.slice(consumed + 1);
        const remainingGrouped = new Map<string, { prizeId: string; label: string; color: string | null; count: number }>();
        for (const t of afterTokens) {
          if (!remainingGrouped.has(t.prizeId)) remainingGrouped.set(t.prizeId, { prizeId: t.prizeId, label: t.label, color: t.color, count: 0 });
          remainingGrouped.get(t.prizeId)!.count++;
        }
        const remainingResponse = Array.from(remainingGrouped.values()).map(r => ({ prizeId: r.prizeId, count: r.count, label: r.label, color: r.color })).filter(r => r.count > 0);
        const deferredLogs: Array<{ type: string; message: string; metadata: any }> = [
          { type: 'ROULETTE_SPIN', message: 'Spin ruleta (BY_TOKEN)', metadata: { sessionId: session.id, prizeId: chosenToken.prizeId, order: nextOrder, remainingTotal: afterTokens.length, finished: finishedNow, phase: twoPhase ? 'REVEALED' : 'LEGACY_REDEEM', tokenId: chosenToken.tokenId } },
        ];
        if (twoPhase && revealedAt) {
          deferredLogs.push({
            type: 'TOKEN_REVEALED',
            message: 'Token prize revealed (BY_TOKEN)',
            metadata: {
              sessionId: session.id,
              tokenId: chosenToken.tokenId,
              prizeId: chosenToken.prizeId,
              assignedPrizeId: chosenToken.prizeId,
              order: nextOrder,
              revealedAt
            }
          });
        }
        if (finishedNow) {
          const distribution = computeDistribution(snapshot, session.spinsHistory, chosenToken.prizeId);
          deferredLogs.push({ type: 'ROULETTE_FINISH', message: 'Ruleta finalizada', metadata: { sessionId: session.id, totalSpins: nextOrder, distribution } });
        }
        if (twoPhase) {
          return {
            status: 200,
            body: {
              phase: 'REVEALED',
              tokenId: chosenToken.tokenId,
              prize: { prizeId: chosenToken.prizeId, label: chosenToken.label, color: chosenToken.color },
              // Backwards-compatible legacy field expected by some callers/tests
              chosen: { prizeId: chosenToken.prizeId, label: chosenToken.label, color: chosenToken.color, tokenId: chosenToken.tokenId },
              order: nextOrder,
              finished: finishedNow,
              remaining: remainingResponse,
              timestamps: { revealedAt },
              _logs: deferredLogs,
            }
          } as const;
        }
        return { status: 200, body: { chosen: { prizeId: chosenToken.prizeId, label: chosenToken.label, color: chosenToken.color, tokenId: chosenToken.tokenId }, order: nextOrder, finished: finishedNow, remaining: remainingResponse, _logs: deferredLogs } } as const;
      } else {
        return { status: 500, body: { code: 'UNKNOWN_MODE', message: 'Modo desconocido' } } as const;
      }
    });
    if (result.status === 200 && (result.body as any)._logs) {
      const logs = (result.body as any)._logs as Array<{ type: string; message: string; metadata: any }>;
      // Ejecutar en paralelo sin await para no retrasar respuesta (best-effort)
      Promise.allSettled(logs.map(l => logEvent(l.type, l.message, l.metadata))).catch(() => {});
      delete (result.body as any)._logs;
    }
    if ('code' in result.body || 'error' in result.body) {
      const code = (result.body as any).code || (result.body as any).error;
      return apiError(code, (result.body as any).message || code, (result.body as any).details, result.status);
    }
    return apiOk(result.body, result.status);
  } catch (e: any) {
    // eslint-disable-next-line no-console
    console.error("[ROULETTE_SPIN_ERROR]", e);
    return apiError('SPIN_FAILED', 'Spin fallido', undefined, 500);
  }
}
